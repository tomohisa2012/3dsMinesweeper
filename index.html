<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PS1風 WW2 TPS Prototype</title>
  <style>
    :root {
      color-scheme: dark;
      --hud: #d9d2a7;
      --panel: rgba(18, 22, 20, 0.82);
      --accent: #d2a66f;
      --danger: #df5a4b;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #121211;
      font-family: "MS Gothic", "Courier New", monospace;
      image-rendering: pixelated;
    }

    #game {
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: crosshair;
    }

    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      background: var(--panel);
      border: 2px solid #665f44;
      color: var(--hud);
      padding: 10px 12px;
      min-width: 270px;
      font-size: 13px;
      line-height: 1.45;
      box-shadow: 0 0 0 2px #1d1d1a inset;
      white-space: pre-line;
    }

    #message {
      margin-top: 7px;
      color: var(--accent);
      font-weight: bold;
      min-height: 1.2em;
    }

    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 22px;
      height: 22px;
      margin-left: -11px;
      margin-top: -11px;
      pointer-events: none;
      opacity: 0.8;
    }

    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(245, 236, 207, 0.85);
    }

    #crosshair::before {
      left: 10px;
      top: 1px;
      width: 2px;
      height: 20px;
    }

    #crosshair::after {
      left: 1px;
      top: 10px;
      width: 20px;
      height: 2px;
    }

    #warning {
      color: var(--danger);
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="crosshair"></div>
  <div id="hud">
    <div id="stats">HP: 100 | Ammo: ∞ | Enemies: 0</div>
    <div>Move: WASD / Aim: Right Click</div>
    <div>Shoot: Left Click / Sprint: Shift</div>
    <div>Camera: Mouse Drag</div>
    <div id="warning">重め操作: 加速・減速あり</div>
    <div id="message"></div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";

    const canvas = document.getElementById("game");
    const statsEl = document.getElementById("stats");
    const messageEl = document.getElementById("message");

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.4));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x71684f);
    scene.fog = new THREE.Fog(0x71684f, 18, 85);

    const camera = new THREE.PerspectiveCamera(68, window.innerWidth / window.innerHeight, 0.1, 150);

    const sun = new THREE.DirectionalLight(0xfff0ca, 1.05);
    sun.position.set(10, 18, 8);
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0x6d6248, 1.25));

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(140, 140, 24, 24),
      new THREE.MeshLambertMaterial({ color: 0x6a6e4d, flatShading: true })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const decoMat = new THREE.MeshLambertMaterial({ color: 0x7d7156, flatShading: true });
    const bunkerMat = new THREE.MeshLambertMaterial({ color: 0x4a4f46, flatShading: true });
    function addBox(x, z, w, h, d, material = decoMat) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
      m.position.set(x, h / 2, z);
      scene.add(m);
      return m;
    }

    for (let i = 0; i < 28; i++) {
      const x = (Math.random() - 0.5) * 110;
      const z = (Math.random() - 0.5) * 110;
      addBox(x, z, 1.7, 1.2, 1.7);
    }

    addBox(-20, -8, 12, 4.6, 7, bunkerMat);
    addBox(14, 16, 8, 3.2, 8, bunkerMat);
    addBox(21, -20, 11, 4.8, 5, bunkerMat);

    const player = {
      body: new THREE.Group(),
      hp: 100,
      velocity: new THREE.Vector3(),
      speed: new THREE.Vector3(),
      yaw: Math.PI,
      pitch: 0.1,
      shootCooldown: 0,
      isAiming: false,
      alive: true
    };

    const torso = new THREE.Mesh(
      new THREE.BoxGeometry(0.9, 1.2, 0.5),
      new THREE.MeshLambertMaterial({ color: 0x8a6f4f, flatShading: true })
    );
    torso.position.y = 1.3;
    const helmet = new THREE.Mesh(
      new THREE.BoxGeometry(0.62, 0.45, 0.62),
      new THREE.MeshLambertMaterial({ color: 0x4f5d3f, flatShading: true })
    );
    helmet.position.y = 2.1;
    const rifle = new THREE.Mesh(
      new THREE.BoxGeometry(0.15, 0.15, 1.2),
      new THREE.MeshLambertMaterial({ color: 0x2f2a23, flatShading: true })
    );
    rifle.position.set(0.35, 1.35, 0.25);
    rifle.rotation.x = Math.PI / 2;
    player.body.add(torso, helmet, rifle);
    player.body.position.set(0, 0, 8);
    player.body.traverse((obj) => {
      if (obj.isMesh) {
        obj.frustumCulled = false;
      }
    });
    scene.add(player.body);

    const viewGun = new THREE.Group();
    const viewGunMain = new THREE.Mesh(
      new THREE.BoxGeometry(0.18, 0.16, 0.9),
      new THREE.MeshLambertMaterial({ color: 0x2a241f, flatShading: true })
    );
    const viewGunStock = new THREE.Mesh(
      new THREE.BoxGeometry(0.16, 0.15, 0.4),
      new THREE.MeshLambertMaterial({ color: 0x4d3a2b, flatShading: true })
    );
    viewGunMain.position.set(0, 0, -0.4);
    viewGunStock.position.set(0, -0.02, 0.2);
    viewGun.add(viewGunMain, viewGunStock);
    viewGun.position.set(0.42, -0.38, -0.75);
    camera.add(viewGun);
    scene.add(camera);

    const enemies = [];
    function spawnEnemy(x, z) {
      const g = new THREE.Group();
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.85, 1.15, 0.52),
        new THREE.MeshLambertMaterial({ color: 0x5f6f75, flatShading: true })
      );
      body.position.y = 1.2;
      const cap = new THREE.Mesh(
        new THREE.BoxGeometry(0.55, 0.38, 0.55),
        new THREE.MeshLambertMaterial({ color: 0x3d4a4f, flatShading: true })
      );
      cap.position.y = 1.97;
      g.add(body, cap);
      g.position.set(x, 0, z);
      scene.add(g);
      enemies.push({ mesh: g, hp: 34, attackCd: Math.random() * 0.8, alive: true });
    }

    spawnEnemy(-16, -12);
    spawnEnemy(4, -18);
    spawnEnemy(22, -9);
    spawnEnemy(-8, 12);

    const pressed = new Set();
    let drag = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    window.addEventListener("keydown", (e) => pressed.add(e.code));
    window.addEventListener("keyup", (e) => pressed.delete(e.code));

    canvas.addEventListener("mousedown", (e) => {
      if (e.button === 2) {
        player.isAiming = true;
      }
      if (e.button === 0) {
        shoot();
      }
      drag = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    window.addEventListener("mouseup", (e) => {
      drag = false;
      if (e.button === 2) {
        player.isAiming = false;
      }
    });

    window.addEventListener("mousemove", (e) => {
      if (!drag) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      player.yaw -= dx * 0.005;
      player.pitch = THREE.MathUtils.clamp(player.pitch - dy * 0.004, -0.45, 0.6);
    });

    window.addEventListener("contextmenu", (e) => e.preventDefault());
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const raycaster = new THREE.Raycaster();
    const lookDir = new THREE.Vector3();
    const cameraTarget = new THREE.Vector3();

    function shoot() {
      if (!player.alive || player.shootCooldown > 0) return;
      player.shootCooldown = 0.29;
      messageEl.textContent = "Bang!";

      camera.getWorldDirection(lookDir);
      raycaster.set(camera.position, lookDir);
      const living = enemies.filter((e) => e.alive).map((e) => e.mesh);
      const hit = raycaster.intersectObjects(living, true)[0];

      if (hit) {
        const enemy = enemies.find((e) => e.mesh === hit.object.parent || e.mesh === hit.object);
        if (enemy && enemy.alive) {
          enemy.hp -= 17;
          messageEl.textContent = "Hit!";
          if (enemy.hp <= 0) {
            enemy.alive = false;
            enemy.mesh.visible = false;
            messageEl.textContent = "Enemy Down";
          }
        }
      }
    }

    function controlPlayer(dt) {
      if (!player.alive) return;
      const accel = pressed.has("ShiftLeft") || pressed.has("ShiftRight") ? 11 : 7.2;
      const maxSpeed = pressed.has("ShiftLeft") || pressed.has("ShiftRight") ? 8.4 : 5.6;
      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
      const right = new THREE.Vector3(forward.z, 0, -forward.x);

      const wish = new THREE.Vector3();
      if (pressed.has("KeyW")) wish.add(forward);
      if (pressed.has("KeyS")) wish.sub(forward);
      if (pressed.has("KeyA")) wish.sub(right);
      if (pressed.has("KeyD")) wish.add(right);
      if (wish.lengthSq() > 0) wish.normalize();

      const target = wish.multiplyScalar(maxSpeed);
      player.speed.lerp(target, Math.min(1, accel * dt * 0.34));
      player.velocity.copy(player.speed);
      player.body.position.addScaledVector(player.velocity, dt);

      player.body.position.x = THREE.MathUtils.clamp(player.body.position.x, -62, 62);
      player.body.position.z = THREE.MathUtils.clamp(player.body.position.z, -62, 62);

      if (wish.lengthSq() > 0.01) {
        const bodyYaw = Math.atan2(player.velocity.x, player.velocity.z);
        player.body.rotation.y = THREE.MathUtils.lerp(player.body.rotation.y, bodyYaw, 0.16);
      }

      const camDistance = player.isAiming ? 4.9 : 7.4;
      const camHeight = player.isAiming ? 2.7 : 3.4;
      const shoulderOffset = player.isAiming ? 0.42 : 1.05;
      const camOffset = new THREE.Vector3(
        -Math.sin(player.yaw) * camDistance + Math.cos(player.yaw) * shoulderOffset,
        camHeight,
        -Math.cos(player.yaw) * camDistance - Math.sin(player.yaw) * shoulderOffset
      );

      const pitchMatrix = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw)), player.pitch);
      camOffset.applyMatrix4(pitchMatrix);

      cameraTarget.set(
        player.body.position.x + Math.cos(player.yaw) * 0.45,
        player.body.position.y + 1.65,
        player.body.position.z - Math.sin(player.yaw) * 0.45
      );

      camera.position.lerp(cameraTarget.clone().add(camOffset), 0.15);
      camera.lookAt(cameraTarget);
      viewGun.visible = player.alive;
      viewGun.position.x = player.isAiming ? 0.22 : 0.42;
      viewGun.position.y = player.isAiming ? -0.28 : -0.38;
      viewGun.rotation.x = player.isAiming ? -0.05 : -0.15;
    }

    function updateEnemies(dt) {
      if (!player.alive) return;
      const p = player.body.position;
      enemies.forEach((enemy) => {
        if (!enemy.alive) return;
        const ep = enemy.mesh.position;
        const toPlayer = new THREE.Vector3().subVectors(p, ep);
        const dist = toPlayer.length();

        if (dist > 2.4) {
          toPlayer.normalize();
          ep.addScaledVector(toPlayer, dt * 2.4);
          enemy.mesh.rotation.y = Math.atan2(toPlayer.x, toPlayer.z);
        } else {
          enemy.attackCd -= dt;
          if (enemy.attackCd <= 0) {
            enemy.attackCd = 1.05;
            player.hp -= 11;
            messageEl.textContent = "被弾!";
            if (player.hp <= 0) {
              player.hp = 0;
              player.alive = false;
              messageEl.textContent = "Mission Failed - Reload to retry";
            }
          }
        }
      });
    }

    function updateHud() {
      const aliveEnemies = enemies.filter((e) => e.alive).length;
      statsEl.textContent = `HP: ${player.hp} | Ammo: ∞ | Enemies: ${aliveEnemies}`;
      if (aliveEnemies === 0 && player.alive) {
        messageEl.textContent = "Mission Complete";
      }
    }

    const clock = new THREE.Clock();
    function loop() {
      const dt = Math.min(clock.getDelta(), 0.05);
      if (player.shootCooldown > 0) {
        player.shootCooldown -= dt;
      }
      controlPlayer(dt);
      updateEnemies(dt);
      updateHud();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
